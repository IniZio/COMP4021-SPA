{"version":3,"sources":["node_modules/observable-slim/observable-slim.js","primitives/my-element.js"],"names":["MyElement","arguments","_listeners","_mapper","shadowRoot","attachShadow","mode","appendChild","template","content","cloneNode","applyListeners","activateState","instance","querySelectorAll","map","Array","from","node","attributes","filter","attr","name","startsWith","slice","removeAttribute","hasOwnProperty","value","push","data","create","Function","changes","change","currentPath","innerText","setAttribute","remove","clearListeners","diactivateState","handler","bind","addEventListener","el","event","removeEventListener","length","HTMLElement","window","exportTag","Class","prototype","document","currentScript","parentElement","querySelector","customElements","define"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"my-element.d19fe8ce.map","sourceRoot":"../client","sourcesContent":["/*\r\n * \tObservable Slim\r\n *\tVersion 0.0.1\r\n * \thttps://github.com/elliotnb/observable-slim\r\n *\r\n * \tLicensed under the MIT license:\r\n * \thttp://www.opensource.org/licenses/MIT\r\n *\r\n *\tObservable Slim is a singleton that allows you to observe changes made to an object and any nested\r\n *\tchildren of that object. It is intended to assist with one-way data binding, that is, in MVC parlance, \r\n *\treflecting changes in the model to the view. Observable Slim aspires to be as lightweight and easily\r\n *\tunderstood as possible. Minifies down to roughly 3000 characters.\r\n */\r\n\r\n\r\nvar ObservableSlim = (function() {\r\n\t\r\n\t// An array that stores all of the observables created through the public create() method below.\r\n\tvar observables = [];\r\n\t// An array of all the objects that we have assigned Proxies to\r\n\tvar targets = [];\r\n\r\n\t// An array of arrays containing the Proxies created for each target object. targetsProxy is index-matched with \r\n\t// 'targets' -- together, the pair offer a Hash table where the key is not a string nor number, but the actual target object\r\n\tvar targetsProxy = [];\r\n\t\r\n\t// this variable tracks duplicate proxies assigned to the same target.\r\n\t// the 'set' handler below will trigger the same change on all other Proxies tracking the same target.\r\n\t// however, in order to avoid an infinite loop of Proxies triggering and re-triggering one another, we use dupProxy\r\n\t// to track that a given Proxy was modified from the 'set' handler\r\n\tvar dupProxy = null;\r\n\r\n\tvar _getProperty = function(obj, path) {\r\n\t\treturn path.split('.').reduce(function(prev, curr) {\r\n\t\t\treturn prev ? prev[curr] : undefined\r\n\t\t}, obj || self)\r\n\t};\r\n\t\r\n\t/*\tFunction: _create\r\n\t\t\t\tPrivate internal function that is invoked to create a new ES6 Proxy whose changes we can observe through \r\n\t\t\t\tthe Observerable.observe() method.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\ttarget \t\t\t\t- required, plain JavaScript object that we want to observe for changes.\r\n\t\t\t\tdomDelay \t\t\t- batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n\t\t\t\toriginalObservable \t- object, the original observable created by the user, exists for recursion purposes, \r\n\t\t\t\t\t\t\t\t\t  allows one observable to observe change on any nested/child objects.\r\n\t\t\t\toriginalPath \t\t- string, the path of the property in relation to the target on the original observable, \r\n\t\t\t\t\t\t\t\t\t  exists for recursion purposes, allows one observable to observe change on any nested/child objects.\r\n\t\t\t\t\t\t\t\t\t  \r\n\t\t\tReturns:\r\n\t\t\t\tAn ES6 Proxy object.\r\n\t*/\r\n\tvar _create = function(target, domDelay, originalObservable, originalPath) {\r\n\t\t\r\n\t\tvar observable = originalObservable || null;\r\n\t\tvar path = originalPath || \"\";\r\n\t\t\r\n\t\tvar changes = [];\r\n\t\t\r\n\t\tvar _getPath = function(target, property) {\r\n\t\t\tif (target instanceof Array) {\r\n\t\t\t\treturn (path !== \"\") ? (path) : property;\r\n\t\t\t} else {\r\n\t\t\t\treturn (path !== \"\") ? (path + \".\" + property) : property;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar _notifyObservers = function(numChanges) {\r\n\t\t\t\r\n\t\t\t// if the observable is paused, then we don't want to execute any of the observer functions\r\n\t\t\tif (observable.paused === true) return;\r\n\t\t\t\t\t\r\n\t\t\t// execute observer functions on a 10ms settimeout, this prevents the observer functions from being executed \r\n\t\t\t// separately on every change -- this is necessary because the observer functions will often trigger UI updates\r\n \t\t\tif (domDelay === true) {\r\n\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\tif (numChanges === changes.length) {\r\n\t\t\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changes);\r\n\t\t\t\t\t\tchanges = [];\r\n\t\t\t\t\t}\r\n\t\t\t\t},10);\r\n\t\t\t} else {\r\n\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changes);\r\n\t\t\t\tchanges = [];\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar handler = { \r\n\t\t\tget: function(target, property) {\r\n\t\t\t\t\r\n\t\t\t\t// implement a simple check for whether or not the object is a proxy, this helps the .create() method avoid\r\n\t\t\t\t// creating Proxies of Proxies.\r\n\t\t\t\tif (property === \"__getTarget\") {\r\n\t\t\t\t\treturn target;\r\n\t\t\t\t} else if (property === \"__isProxy\") {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t// from the perspective of a given observable on a parent object, return the parent object of the given nested object\r\n\t\t\t\t} else if (property === \"__getParent\") {\r\n\t\t\t\t\treturn function(i) {\r\n\t\t\t\t\t\tif (typeof i === \"undefined\") var i = 1;\r\n\t\t\t\t\t\tvar parentPath = _getPath(target, \"__getParent\").split(\".\");\r\n\t\t\t\t\t\tparentPath.splice(-(i+1),(i+1));\r\n\t\t\t\t\t\treturn _getProperty(observable.parentProxy, parentPath.join(\".\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// for performance improvements, we assign this to a variable so we do not have to lookup the property value again\r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\t\r\n\t\t\t\t// if we are traversing into a new object, then we want to record path to that object and return a new observable.\r\n\t\t\t\t// recursively returning a new observable allows us a single Observable.observe() to monitor all changes on \r\n\t\t\t\t// the target object and any objects nested within.\t\t\t\t\r\n\t\t\t\tif (targetProp instanceof Object && targetProp !== null && target.hasOwnProperty(property)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we've found a proxy nested on the object, then we want to retrieve the original object behind that proxy\r\n\t\t\t\t\tif (targetProp.__isProxy === true) targetProp = targetProp.__getTarget;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we've previously setup a proxy on this target, then...\r\n\t\t\t\t\t//var a = observable.targets.indexOf(targetProp);\r\n\t\t\t\t\tvar a = -1;\r\n\t\t\t\t\tvar observableTargets = observable.targets;\r\n\t\t\t\t\tfor (var i = 0, l = observableTargets.length; i < l; i++) {\r\n\t\t\t\t\t\tif (targetProp === observableTargets[i]) {\r\n\t\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (a > -1) return observable.proxies[a];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we're arrived here, then that means there is no proxy for the object the user just accessed, so we\r\n\t\t\t\t\t// have to create a new proxy for it\r\n\t\t\t\t\tvar newPath = (path !== \"\") ? (path + \".\" + property) : property;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn _create(targetProp, domDelay, observable, newPath);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn targetProp;\r\n\t\t\t\t}\r\n\t\t\t},\r\n \t\t\tdeleteProperty: function(target, property) {\r\n\t\t\t\t\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// in order to report what the previous value was, we must make a copy of it before it is deleted\r\n\t\t\t\tvar previousValue = Object.assign({}, target);\r\n \r\n\t\t\t\t// get the path of the property being deleted\r\n\t\t\t\tvar currentPath = _getPath(target, property);\r\n\t\t\t\t\r\n\t\t\t\t// record the deletion that just took place\r\n\t\t\t\tchanges.push({\"type\":\"delete\",\"target\":target,\"property\":property,\"newValue\":null,\"previousValue\":previousValue[property],\"currentPath\":currentPath,\"proxy\":proxy});\r\n\t\t\t\t\r\n\t\t\t\tif (originalChange === true) {\r\n\t\t\t\t\r\n\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\t\t\t\t\r\n\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\tvar currentTargetProxy = targetsProxy[a];\r\n\r\n\t\t\t\t\tvar b = currentTargetProxy.length;\r\n\t\t\t\t\twhile (b--) {\r\n\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t// make the same delete on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\tdelete currentTargetProxy[b].proxy[property];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\t// perform the delete that we've trapped\r\n\t\t\t\t\tdelete target[property];\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\tset: function(target, property, value, receiver) {\r\n\t\t\t\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// improve performance by saving direct references to the property \r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\t\r\n\t\t\t\t// only record a change if the new value differs from the old one OR if this proxy was not the original proxy to receive the change\r\n\t\t\t\tif (targetProp !== value || originalChange === false) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar typeOfTargetProp = (typeof targetProp);\r\n\t\t\t\t\r\n\t\t\t\t\t// get the path of the object property being modified\r\n\t\t\t\t\tvar currentPath = _getPath(target, property);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// determine if we're adding something new or modifying somethat that already existed\r\n\t\t\t\t\tvar type = \"update\";\r\n\t\t\t\t\tif (typeOfTargetProp === \"undefined\") type = \"add\";\r\n\t\t\t\t\t\r\n\t\t\t\t\t// store the change that just occurred. it is important that we store the change before invoking the other proxies so that the previousValue is correct\r\n\t\t\t\t\tchanges.push({\"type\":type,\"target\":target,\"property\":property,\"newValue\":value,\"previousValue\":receiver[property],\"currentPath\":currentPath,\"proxy\":proxy});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// !!IMPORTANT!! if this proxy was the first proxy to receive the change, then we need to go check and see\r\n\t\t\t\t\t// if there are other proxies for the same project. if there are, then we will modify those proxies as well so the other\r\n\t\t\t\t\t// observers can be modified of the change that has occurred.\r\n\t\t\t\t\tif (originalChange === true) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[a];\r\n\t\t\t\t\t\tfor (var b = 0, l = currentTargetProxy.length; b < l; b++) {\r\n\t\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// invoke the same change on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\t\tcurrentTargetProxy[b].proxy[property] = value;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the property being overwritten is an object, then that means this observable\r\n\t\t\t\t\t\t// will need to stop monitoring this object and any nested objects underneath else they'll become\r\n\t\t\t\t\t\t// orphaned and grow memory usage. we excute this on a setTimeout so that the clean-up process does not block\r\n\t\t\t\t\t\t// the UI rendering -- there's no need to execute the clean up immediately\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (typeOfTargetProp === \"object\" && targetProp !== null) {\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// loop over each property and recursively invoke the `iterate` function for any\r\n\t\t\t\t\t\t\t\t// objects nested on targetProp\r\n\t\t\t\t\t\t\t\t(function iterate(obj) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tvar keys = Object.keys(obj);\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tvar objProp = obj[keys[i]];\r\n\t\t\t\t\t\t\t\t\t\tif (objProp instanceof Object && objProp !== null) iterate(objProp);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if there are any existing target objects (objects that we're already observing)...\r\n\t\t\t\t\t\t\t\t\t//var c = targets.indexOf(obj);\r\n\t\t\t\t\t\t\t\t\tvar c = -1;\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif (obj === targets[i]) {\r\n\t\t\t\t\t\t\t\t\t\t\tc = i;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (c > -1) {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// ...then we want to determine if the observables for that object match our current observable\r\n\t\t\t\t\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[c];\r\n\t\t\t\t\t\t\t\t\t\tvar d = currentTargetProxy.length;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\twhile (d--) {\r\n\t\t\t\t\t\t\t\t\t\t\t// if we do have an observable monitoring the object thats about to be overwritten\r\n\t\t\t\t\t\t\t\t\t\t\t// then we can remove that observable from the target object\r\n\t\t\t\t\t\t\t\t\t\t\tif (observable === currentTargetProxy[d].observable) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTargetProxy.splice(d,1);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// if there are no more observables assigned to the target object, then we can remove\r\n\t\t\t\t\t\t\t\t\t\t// the target object altogether. this is necessary to prevent growing memory consumption particularly with large data sets\r\n\t\t\t\t\t\t\t\t\t\tif (currentTargetProxy.length == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\ttargetsProxy.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t\ttargets.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t})(targetProp)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},10000);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// because the value actually differs than the previous value\r\n\t\t\t\t\t\t// we need to store the new value on the original target object\r\n\t\t\t\t\t\ttarget[property] = value;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// TO DO: the next block of code resolves test case #24, but it results in poor IE11 performance. Find a solution.\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the value we've just set is an object, then we'll need to iterate over it in order to initialize the \r\n\t\t\t\t\t\t// observers/proxies on all nested children of the object\r\n\t\t\t\t\t\t/* if (value instanceof Object && value !== null) {\r\n\t\t\t\t\t\t\t(function iterate(proxy) {\r\n\t\t\t\t\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\t\t\t\t\tvar keys = Object.keys(target);\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t})(proxy[property]);\r\n\t\t\t\t\t\t}; */\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// notify the observer functions that the target has been modified\r\n\t\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// create the proxy that we'll use to observe any changes\r\n\t\tvar proxy = new Proxy(target, handler);\r\n\t\t\r\n\t\t// we don't want to create a new observable if this function was invoked recursively\r\n\t\tif (observable === null) {\r\n\t\t\tobservable = {\"parentTarget\":target, \"domDelay\":domDelay, \"parentProxy\":proxy, \"observers\":[],\"targets\":[target],\"proxies\":[proxy],\"paused\":false,\"path\":path};\r\n\t\t\tobservables.push(observable);\r\n\t\t} else {\r\n\t\t\tobservable.targets.push(target);\r\n\t\t\tobservable.proxies.push(proxy);\r\n\t\t}\r\n\r\n\t\t// store the proxy we've created so it isn't re-created unnecessairly via get handler\r\n\t\tvar proxyItem = {\"target\":target,\"proxy\":proxy,\"observable\":observable};\r\n\t\t\r\n\t\t//var targetPosition = targets.indexOf(target);\r\n\t\tvar targetPosition = -1;\r\n\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\tif (target === targets[i]) {\r\n\t\t\t\ttargetPosition = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// if we have already created a Proxy for this target object then we add it to the corresponding array \r\n\t\t// on targetsProxy (targets and targetsProxy work together as a Hash table indexed by the actual target object).\r\n\t\tif (targetPosition > -1) {\r\n\t\t\ttargetsProxy[targetPosition].push(proxyItem);\r\n\t\t// else this is a target object that we have not yet created a Proxy for, so we must add it to targets,\r\n\t\t// and push a new array on to targetsProxy containing the new Proxy\r\n\t\t} else {\r\n\t\t\ttargets.push(target);\r\n\t\t\ttargetsProxy.push([proxyItem]);\r\n\t\t\ttargetPosition = targets.length - 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn proxy;\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/*\tMethod:\r\n\t\t\t\tPublic method that is invoked to create a new ES6 Proxy whose changes we can observe \r\n\t\t\t\tthrough the Observerable.observe() method.\r\n\t\t\t\r\n\t\t\tParameters\r\n\t\t\t\ttarget - Object, required, plain JavaScript object that we want to observe for changes.\r\n\t\t\t\tdomDelay - Boolean, required, if true, then batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n\t\t\t\tobserver - Function, optional, will be invoked when a change is made to the proxy.\r\n\t\t\t\r\n\t\t\tReturns:\r\n\t\t\t\tAn ES6 Proxy object.\r\n\t\t*/\r\n\t\tcreate: function(target, domDelay, observer) {\r\n\t\t\t\r\n\t\t\t// test if the target is a Proxy, if it is then we need to retrieve the original object behind the Proxy.\r\n\t\t\t// we do not allow creating proxies of proxies because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\tif (target.__isProxy === true) {\r\n\t\t\t\tvar target = target.__getTarget;\r\n\t\t\t\t//if it is, then we should throw an error. we do not allow creating proxies of proxies\r\n\t\t\t\t// because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\t\t//throw new Error(\"ObservableSlim.create() cannot create a Proxy for a target object that is also a Proxy.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// fire off the _create() method -- it will create a new observable and proxy and return the proxy\r\n\t\t\tvar proxy = _create(target, domDelay);\r\n\t\t\t\r\n\t\t\t// assign the observer function\r\n\t\t\tif (typeof observer === \"function\") this.observe(proxy, observer);\r\n\t\t\t\r\n\t\t\t// recursively loop over all nested objects on the proxy we've just created\r\n\t\t\t// this will allow the top observable to observe any changes that occur on a nested object\r\n\t\t\t(function iterate(proxy) {\r\n\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\tvar keys  = Object.keys(target);\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t}\r\n\t\t\t})(proxy);\r\n\t\t\t\r\n\t\t\treturn proxy;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: observe\r\n\t\t\t\tThis method is used to add a new observer function to an existing proxy.\r\n\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method. We want to observe changes made to this object.\r\n\t\t\t\tobserver \t- this function will be invoked when a change is made to the observable (not to be confused with the \r\n\t\t\t\t\t\t\t  observer defined in the create() method).\r\n\t\t\t\r\n\t\t\tReturns:\r\n\t\t\t\tNothing.\r\n\t\t*/\r\n\t\tobserve: function(proxy, observer) {\r\n\t\t\t// loop over all the observables created by the _create() function\r\n\t\t\tvar i = observables.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].observers.push(observer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: pause\r\n\t\t\t\tThis method will prevent any observer functions from being invoked when a change occurs to a proxy.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tpause: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = true;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not pause observable -- matching proxy not found.\");\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: resume\r\n\t\t\t\tThis method will resume execution of any observer functions when a change is made to a proxy.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tresume: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = false;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not resume observable -- matching proxy not found.\");\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: remove\r\n\t\t\t\tThis method will remove the observable and proxy thereby preventing any further callback observers for \r\n\t\t\t\tchanges occuring to the target object.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tremove: function(proxy) {\r\n\t\t\r\n\t\t\tvar matchedObservable = null;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\t\r\n\t\t\tvar c = observables.length;\r\n\t\t\twhile (c--) {\r\n\t\t\t\tif (observables[c].parentProxy === proxy) {\r\n\t\t\t\t\tmatchedObservable = observables[c];\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar a = targetsProxy.length;\r\n\t\t\twhile (a--) {\r\n\t\t\t\tvar b = targetsProxy[a].length;\r\n\t\t\t\twhile (b--) {\r\n\t\t\t\t\tif (targetsProxy[a][b].observable === matchedObservable) {\r\n\t\t\t\t\t\ttargetsProxy[a].splice(b,1);\r\n\t\t\t\t\t\tif (targetsProxy[a].length == 0) {\r\n\t\t\t\t\t\t\ttargetsProxy.splice(a,1);\r\n\t\t\t\t\t\t\ttargets.splice(a,1);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch === true) {\r\n\t\t\t\tobservables.splice(c,1);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n// Export in a try catch to prevent this from erroring out on older browsers\r\ntry { module.exports = ObservableSlim; } catch (err) {};","import slim from 'observable-slim'\n\nclass MyElement extends HTMLElement {\n  constructor () {\n    super(...arguments)\n\n    this._listeners = []\n    this._mapper = {}\n\n    if (!this.shadowRoot) {\n      // Attach shadow DOM\n      this.attachShadow({mode: 'open'})\n      // Append template content to custom element\n      this.shadowRoot.appendChild(this.template.content.cloneNode(true))\n    }\n  }\n\n  connectedCallback () {\n    this.applyListeners()\n    this.activateState()\n  }\n\n  activateState () {\n    const instance = this\n\n    this.shadowRoot.querySelectorAll('*')\n      .map(node => {\n        // Attribute sync\n        Array.from(node.attributes)\n          // e.g. :value\n          .filter(attr => attr.name.startsWith(':'))\n          .map(attr => {\n            const name = attr.name.slice(1)\n            node.removeAttribute(attr.name)\n            if (this._mapper.hasOwnProperty(attr.value)) {\n              this._mapper[attr.value].push({name, node})\n            } else this._mapper[attr.value] = [{name, node}]\n          })\n      })\n\n    this.data = slim.create(\n      instance.data instanceof Function\n      ? instance.data()\n      : instance.hasOwnProperty('data')\n        ? instance.data\n        : {},\n      true,\n      changes => {\n        changes.map(change => \n          instance._mapper[change.currentPath].map(\n            ({name, node}) => {\n              if (name === 'children') {\n                node.innerText = instance.data[change.currentPath]\n              } else node.setAttribute(name, instance.data[change.currentPath])\n            }\n          )\n        )\n      // console.log(JSON.stringify(changes, null, 2))\n      }\n    )\n  }\n\n  diactivateState () {\n    slim.remove(this.data)\n  }\n\n  disconnectedCallback () {\n    this.clearListeners()\n    this.diactivateState()\n  }\n\n  applyListeners () {\n    const instance = this\n\n    this.shadowRoot.querySelectorAll('*')\n      .map(node =>\n        Array.from(node.attributes)\n          // e.g. @click\n          .filter(attr => attr.name.startsWith('@'))\n          .map(attr => {\n            node.removeAttribute(attr.name)\n            if (instance[attr.value] instanceof Function) {\n              const handler = instance[attr.value].bind(instance)\n              node.addEventListener(attr.name.slice(1), handler)\n              instance._listeners.push({el: node, event: attr.name.slice(1), handler})\n            }\n          })\n      )\n  }\n\n  clearListeners () {\n    this._listeners.map(({el, event, handler}) => el.removeEventListener(event, handler))\n    this._listeners.length = 0\n  }\n}\n\nwindow.MyElement = MyElement\n\n// Define custom element\nwindow.exportTag = (name = '', Class = class extends MyElement {}) => {\n  Class.template = Class.prototype.template = document.currentScript.parentElement.querySelector('template')\n  return window.customElements.define(name, Class)\n}\n\nexport default MyElement\n"]}