{"version":3,"sources":["node_modules/observable-slim/observable-slim.js","primitives/my-element.js"],"names":["SingleSlim","instance","createInstance","object","create","getInstance","path","paths","obj","Array","isArray","split","val","idx","length","set","value","schema","pList","len","i","elem","MyElement","arguments","_listeners","_mapper","context","_ctxMapper","shadowRoot","attachShadow","mode","appendChild","template","content","cloneNode","applyListeners","activateState","activateContext","initial","data","Function","querySelectorAll","map","from","node","attributes","filter","attr","name","startsWith","slice","removeAttribute","innerText","setAttribute","hasOwnProperty","push","changes","console","log","change","currentPath","Object","keys","newNode","remove","observe","clearListeners","diactivateState","handler","bind","addEventListener","el","event","removeEventListener","HTMLElement","window","exportTag","Class","prototype","document","currentScript","parentElement","querySelector","customElements","define"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"my-element.efa77084.map","sourceRoot":"../client","sourcesContent":["/*\r\n * \tObservable Slim\r\n *\tVersion 0.0.1\r\n * \thttps://github.com/elliotnb/observable-slim\r\n *\r\n * \tLicensed under the MIT license:\r\n * \thttp://www.opensource.org/licenses/MIT\r\n *\r\n *\tObservable Slim is a singleton that allows you to observe changes made to an object and any nested\r\n *\tchildren of that object. It is intended to assist with one-way data binding, that is, in MVC parlance, \r\n *\treflecting changes in the model to the view. Observable Slim aspires to be as lightweight and easily\r\n *\tunderstood as possible. Minifies down to roughly 3000 characters.\r\n */\r\n\r\n\r\nvar ObservableSlim = (function() {\r\n\t\r\n\t// An array that stores all of the observables created through the public create() method below.\r\n\tvar observables = [];\r\n\t// An array of all the objects that we have assigned Proxies to\r\n\tvar targets = [];\r\n\r\n\t// An array of arrays containing the Proxies created for each target object. targetsProxy is index-matched with \r\n\t// 'targets' -- together, the pair offer a Hash table where the key is not a string nor number, but the actual target object\r\n\tvar targetsProxy = [];\r\n\t\r\n\t// this variable tracks duplicate proxies assigned to the same target.\r\n\t// the 'set' handler below will trigger the same change on all other Proxies tracking the same target.\r\n\t// however, in order to avoid an infinite loop of Proxies triggering and re-triggering one another, we use dupProxy\r\n\t// to track that a given Proxy was modified from the 'set' handler\r\n\tvar dupProxy = null;\r\n\r\n\tvar _getProperty = function(obj, path) {\r\n\t\treturn path.split('.').reduce(function(prev, curr) {\r\n\t\t\treturn prev ? prev[curr] : undefined\r\n\t\t}, obj || self)\r\n\t};\r\n\t\r\n\t/*\tFunction: _create\r\n\t\t\t\tPrivate internal function that is invoked to create a new ES6 Proxy whose changes we can observe through \r\n\t\t\t\tthe Observerable.observe() method.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\ttarget \t\t\t\t- required, plain JavaScript object that we want to observe for changes.\r\n\t\t\t\tdomDelay \t\t\t- batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n\t\t\t\toriginalObservable \t- object, the original observable created by the user, exists for recursion purposes, \r\n\t\t\t\t\t\t\t\t\t  allows one observable to observe change on any nested/child objects.\r\n\t\t\t\toriginalPath \t\t- string, the path of the property in relation to the target on the original observable, \r\n\t\t\t\t\t\t\t\t\t  exists for recursion purposes, allows one observable to observe change on any nested/child objects.\r\n\t\t\t\t\t\t\t\t\t  \r\n\t\t\tReturns:\r\n\t\t\t\tAn ES6 Proxy object.\r\n\t*/\r\n\tvar _create = function(target, domDelay, originalObservable, originalPath) {\r\n\t\t\r\n\t\tvar observable = originalObservable || null;\r\n\t\tvar path = originalPath || \"\";\r\n\t\t\r\n\t\tvar changes = [];\r\n\t\t\r\n\t\tvar _getPath = function(target, property) {\r\n\t\t\tif (target instanceof Array) {\r\n\t\t\t\treturn (path !== \"\") ? (path) : property;\r\n\t\t\t} else {\r\n\t\t\t\treturn (path !== \"\") ? (path + \".\" + property) : property;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar _notifyObservers = function(numChanges) {\r\n\t\t\t\r\n\t\t\t// if the observable is paused, then we don't want to execute any of the observer functions\r\n\t\t\tif (observable.paused === true) return;\r\n\t\t\t\t\t\r\n\t\t\t// execute observer functions on a 10ms settimeout, this prevents the observer functions from being executed \r\n\t\t\t// separately on every change -- this is necessary because the observer functions will often trigger UI updates\r\n \t\t\tif (domDelay === true) {\r\n\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\tif (numChanges === changes.length) {\r\n\t\t\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changes);\r\n\t\t\t\t\t\tchanges = [];\r\n\t\t\t\t\t}\r\n\t\t\t\t},10);\r\n\t\t\t} else {\r\n\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changes);\r\n\t\t\t\tchanges = [];\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar handler = { \r\n\t\t\tget: function(target, property) {\r\n\t\t\t\t\r\n\t\t\t\t// implement a simple check for whether or not the object is a proxy, this helps the .create() method avoid\r\n\t\t\t\t// creating Proxies of Proxies.\r\n\t\t\t\tif (property === \"__getTarget\") {\r\n\t\t\t\t\treturn target;\r\n\t\t\t\t} else if (property === \"__isProxy\") {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t// from the perspective of a given observable on a parent object, return the parent object of the given nested object\r\n\t\t\t\t} else if (property === \"__getParent\") {\r\n\t\t\t\t\treturn function(i) {\r\n\t\t\t\t\t\tif (typeof i === \"undefined\") var i = 1;\r\n\t\t\t\t\t\tvar parentPath = _getPath(target, \"__getParent\").split(\".\");\r\n\t\t\t\t\t\tparentPath.splice(-(i+1),(i+1));\r\n\t\t\t\t\t\treturn _getProperty(observable.parentProxy, parentPath.join(\".\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// for performance improvements, we assign this to a variable so we do not have to lookup the property value again\r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\t\r\n\t\t\t\t// if we are traversing into a new object, then we want to record path to that object and return a new observable.\r\n\t\t\t\t// recursively returning a new observable allows us a single Observable.observe() to monitor all changes on \r\n\t\t\t\t// the target object and any objects nested within.\t\t\t\t\r\n\t\t\t\tif (targetProp instanceof Object && targetProp !== null && target.hasOwnProperty(property)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we've found a proxy nested on the object, then we want to retrieve the original object behind that proxy\r\n\t\t\t\t\tif (targetProp.__isProxy === true) targetProp = targetProp.__getTarget;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we've previously setup a proxy on this target, then...\r\n\t\t\t\t\t//var a = observable.targets.indexOf(targetProp);\r\n\t\t\t\t\tvar a = -1;\r\n\t\t\t\t\tvar observableTargets = observable.targets;\r\n\t\t\t\t\tfor (var i = 0, l = observableTargets.length; i < l; i++) {\r\n\t\t\t\t\t\tif (targetProp === observableTargets[i]) {\r\n\t\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (a > -1) return observable.proxies[a];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we're arrived here, then that means there is no proxy for the object the user just accessed, so we\r\n\t\t\t\t\t// have to create a new proxy for it\r\n\t\t\t\t\tvar newPath = (path !== \"\") ? (path + \".\" + property) : property;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn _create(targetProp, domDelay, observable, newPath);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn targetProp;\r\n\t\t\t\t}\r\n\t\t\t},\r\n \t\t\tdeleteProperty: function(target, property) {\r\n\t\t\t\t\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// in order to report what the previous value was, we must make a copy of it before it is deleted\r\n\t\t\t\tvar previousValue = Object.assign({}, target);\r\n \r\n\t\t\t\t// get the path of the property being deleted\r\n\t\t\t\tvar currentPath = _getPath(target, property);\r\n\t\t\t\t\r\n\t\t\t\t// record the deletion that just took place\r\n\t\t\t\tchanges.push({\"type\":\"delete\",\"target\":target,\"property\":property,\"newValue\":null,\"previousValue\":previousValue[property],\"currentPath\":currentPath,\"proxy\":proxy});\r\n\t\t\t\t\r\n\t\t\t\tif (originalChange === true) {\r\n\t\t\t\t\r\n\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\t\t\t\t\r\n\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\tvar currentTargetProxy = targetsProxy[a];\r\n\r\n\t\t\t\t\tvar b = currentTargetProxy.length;\r\n\t\t\t\t\twhile (b--) {\r\n\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t// make the same delete on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\tdelete currentTargetProxy[b].proxy[property];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\t// perform the delete that we've trapped\r\n\t\t\t\t\tdelete target[property];\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\tset: function(target, property, value, receiver) {\r\n\t\t\t\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// improve performance by saving direct references to the property \r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\t\r\n\t\t\t\t// only record a change if the new value differs from the old one OR if this proxy was not the original proxy to receive the change\r\n\t\t\t\tif (targetProp !== value || originalChange === false) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar typeOfTargetProp = (typeof targetProp);\r\n\t\t\t\t\r\n\t\t\t\t\t// get the path of the object property being modified\r\n\t\t\t\t\tvar currentPath = _getPath(target, property);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// determine if we're adding something new or modifying somethat that already existed\r\n\t\t\t\t\tvar type = \"update\";\r\n\t\t\t\t\tif (typeOfTargetProp === \"undefined\") type = \"add\";\r\n\t\t\t\t\t\r\n\t\t\t\t\t// store the change that just occurred. it is important that we store the change before invoking the other proxies so that the previousValue is correct\r\n\t\t\t\t\tchanges.push({\"type\":type,\"target\":target,\"property\":property,\"newValue\":value,\"previousValue\":receiver[property],\"currentPath\":currentPath,\"proxy\":proxy});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// !!IMPORTANT!! if this proxy was the first proxy to receive the change, then we need to go check and see\r\n\t\t\t\t\t// if there are other proxies for the same project. if there are, then we will modify those proxies as well so the other\r\n\t\t\t\t\t// observers can be modified of the change that has occurred.\r\n\t\t\t\t\tif (originalChange === true) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[a];\r\n\t\t\t\t\t\tfor (var b = 0, l = currentTargetProxy.length; b < l; b++) {\r\n\t\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// invoke the same change on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\t\tcurrentTargetProxy[b].proxy[property] = value;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the property being overwritten is an object, then that means this observable\r\n\t\t\t\t\t\t// will need to stop monitoring this object and any nested objects underneath else they'll become\r\n\t\t\t\t\t\t// orphaned and grow memory usage. we excute this on a setTimeout so that the clean-up process does not block\r\n\t\t\t\t\t\t// the UI rendering -- there's no need to execute the clean up immediately\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (typeOfTargetProp === \"object\" && targetProp !== null) {\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// loop over each property and recursively invoke the `iterate` function for any\r\n\t\t\t\t\t\t\t\t// objects nested on targetProp\r\n\t\t\t\t\t\t\t\t(function iterate(obj) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tvar keys = Object.keys(obj);\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tvar objProp = obj[keys[i]];\r\n\t\t\t\t\t\t\t\t\t\tif (objProp instanceof Object && objProp !== null) iterate(objProp);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if there are any existing target objects (objects that we're already observing)...\r\n\t\t\t\t\t\t\t\t\t//var c = targets.indexOf(obj);\r\n\t\t\t\t\t\t\t\t\tvar c = -1;\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif (obj === targets[i]) {\r\n\t\t\t\t\t\t\t\t\t\t\tc = i;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (c > -1) {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// ...then we want to determine if the observables for that object match our current observable\r\n\t\t\t\t\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[c];\r\n\t\t\t\t\t\t\t\t\t\tvar d = currentTargetProxy.length;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\twhile (d--) {\r\n\t\t\t\t\t\t\t\t\t\t\t// if we do have an observable monitoring the object thats about to be overwritten\r\n\t\t\t\t\t\t\t\t\t\t\t// then we can remove that observable from the target object\r\n\t\t\t\t\t\t\t\t\t\t\tif (observable === currentTargetProxy[d].observable) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTargetProxy.splice(d,1);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// if there are no more observables assigned to the target object, then we can remove\r\n\t\t\t\t\t\t\t\t\t\t// the target object altogether. this is necessary to prevent growing memory consumption particularly with large data sets\r\n\t\t\t\t\t\t\t\t\t\tif (currentTargetProxy.length == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\ttargetsProxy.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t\ttargets.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t})(targetProp)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},10000);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// because the value actually differs than the previous value\r\n\t\t\t\t\t\t// we need to store the new value on the original target object\r\n\t\t\t\t\t\ttarget[property] = value;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// TO DO: the next block of code resolves test case #24, but it results in poor IE11 performance. Find a solution.\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the value we've just set is an object, then we'll need to iterate over it in order to initialize the \r\n\t\t\t\t\t\t// observers/proxies on all nested children of the object\r\n\t\t\t\t\t\t/* if (value instanceof Object && value !== null) {\r\n\t\t\t\t\t\t\t(function iterate(proxy) {\r\n\t\t\t\t\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\t\t\t\t\tvar keys = Object.keys(target);\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t})(proxy[property]);\r\n\t\t\t\t\t\t}; */\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// notify the observer functions that the target has been modified\r\n\t\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// create the proxy that we'll use to observe any changes\r\n\t\tvar proxy = new Proxy(target, handler);\r\n\t\t\r\n\t\t// we don't want to create a new observable if this function was invoked recursively\r\n\t\tif (observable === null) {\r\n\t\t\tobservable = {\"parentTarget\":target, \"domDelay\":domDelay, \"parentProxy\":proxy, \"observers\":[],\"targets\":[target],\"proxies\":[proxy],\"paused\":false,\"path\":path};\r\n\t\t\tobservables.push(observable);\r\n\t\t} else {\r\n\t\t\tobservable.targets.push(target);\r\n\t\t\tobservable.proxies.push(proxy);\r\n\t\t}\r\n\r\n\t\t// store the proxy we've created so it isn't re-created unnecessairly via get handler\r\n\t\tvar proxyItem = {\"target\":target,\"proxy\":proxy,\"observable\":observable};\r\n\t\t\r\n\t\t//var targetPosition = targets.indexOf(target);\r\n\t\tvar targetPosition = -1;\r\n\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\tif (target === targets[i]) {\r\n\t\t\t\ttargetPosition = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// if we have already created a Proxy for this target object then we add it to the corresponding array \r\n\t\t// on targetsProxy (targets and targetsProxy work together as a Hash table indexed by the actual target object).\r\n\t\tif (targetPosition > -1) {\r\n\t\t\ttargetsProxy[targetPosition].push(proxyItem);\r\n\t\t// else this is a target object that we have not yet created a Proxy for, so we must add it to targets,\r\n\t\t// and push a new array on to targetsProxy containing the new Proxy\r\n\t\t} else {\r\n\t\t\ttargets.push(target);\r\n\t\t\ttargetsProxy.push([proxyItem]);\r\n\t\t\ttargetPosition = targets.length - 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn proxy;\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/*\tMethod:\r\n\t\t\t\tPublic method that is invoked to create a new ES6 Proxy whose changes we can observe \r\n\t\t\t\tthrough the Observerable.observe() method.\r\n\t\t\t\r\n\t\t\tParameters\r\n\t\t\t\ttarget - Object, required, plain JavaScript object that we want to observe for changes.\r\n\t\t\t\tdomDelay - Boolean, required, if true, then batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n\t\t\t\tobserver - Function, optional, will be invoked when a change is made to the proxy.\r\n\t\t\t\r\n\t\t\tReturns:\r\n\t\t\t\tAn ES6 Proxy object.\r\n\t\t*/\r\n\t\tcreate: function(target, domDelay, observer) {\r\n\t\t\t\r\n\t\t\t// test if the target is a Proxy, if it is then we need to retrieve the original object behind the Proxy.\r\n\t\t\t// we do not allow creating proxies of proxies because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\tif (target.__isProxy === true) {\r\n\t\t\t\tvar target = target.__getTarget;\r\n\t\t\t\t//if it is, then we should throw an error. we do not allow creating proxies of proxies\r\n\t\t\t\t// because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\t\t//throw new Error(\"ObservableSlim.create() cannot create a Proxy for a target object that is also a Proxy.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// fire off the _create() method -- it will create a new observable and proxy and return the proxy\r\n\t\t\tvar proxy = _create(target, domDelay);\r\n\t\t\t\r\n\t\t\t// assign the observer function\r\n\t\t\tif (typeof observer === \"function\") this.observe(proxy, observer);\r\n\t\t\t\r\n\t\t\t// recursively loop over all nested objects on the proxy we've just created\r\n\t\t\t// this will allow the top observable to observe any changes that occur on a nested object\r\n\t\t\t(function iterate(proxy) {\r\n\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\tvar keys  = Object.keys(target);\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t}\r\n\t\t\t})(proxy);\r\n\t\t\t\r\n\t\t\treturn proxy;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: observe\r\n\t\t\t\tThis method is used to add a new observer function to an existing proxy.\r\n\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method. We want to observe changes made to this object.\r\n\t\t\t\tobserver \t- this function will be invoked when a change is made to the observable (not to be confused with the \r\n\t\t\t\t\t\t\t  observer defined in the create() method).\r\n\t\t\t\r\n\t\t\tReturns:\r\n\t\t\t\tNothing.\r\n\t\t*/\r\n\t\tobserve: function(proxy, observer) {\r\n\t\t\t// loop over all the observables created by the _create() function\r\n\t\t\tvar i = observables.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].observers.push(observer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: pause\r\n\t\t\t\tThis method will prevent any observer functions from being invoked when a change occurs to a proxy.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tpause: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = true;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not pause observable -- matching proxy not found.\");\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: resume\r\n\t\t\t\tThis method will resume execution of any observer functions when a change is made to a proxy.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tresume: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = false;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not resume observable -- matching proxy not found.\");\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: remove\r\n\t\t\t\tThis method will remove the observable and proxy thereby preventing any further callback observers for \r\n\t\t\t\tchanges occuring to the target object.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tremove: function(proxy) {\r\n\t\t\r\n\t\t\tvar matchedObservable = null;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\t\r\n\t\t\tvar c = observables.length;\r\n\t\t\twhile (c--) {\r\n\t\t\t\tif (observables[c].parentProxy === proxy) {\r\n\t\t\t\t\tmatchedObservable = observables[c];\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar a = targetsProxy.length;\r\n\t\t\twhile (a--) {\r\n\t\t\t\tvar b = targetsProxy[a].length;\r\n\t\t\t\twhile (b--) {\r\n\t\t\t\t\tif (targetsProxy[a][b].observable === matchedObservable) {\r\n\t\t\t\t\t\ttargetsProxy[a].splice(b,1);\r\n\t\t\t\t\t\tif (targetsProxy[a].length == 0) {\r\n\t\t\t\t\t\t\ttargetsProxy.splice(a,1);\r\n\t\t\t\t\t\t\ttargets.splice(a,1);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch === true) {\r\n\t\t\t\tobservables.splice(c,1);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n// Export in a try catch to prevent this from erroring out on older browsers\r\ntry { module.exports = ObservableSlim; } catch (err) {};","import slim from 'observable-slim'\n\nconst SingleSlim = (() => {\n  let instance\n\n  function createInstance () {\n      const object = slim.create({}, true)\n      return object\n  }\n\n  return {\n      getInstance () {\n          if (!instance) {\n              instance = createInstance()\n          }\n          return instance\n      }\n  }\n})()\n\nfunction path (paths, obj) {\n  paths = Array.isArray(paths) ? paths : paths.split('.')\n  let val = obj\n  let idx = 0\n  while (idx < paths.length) {\n    if (val == null) {\n      return\n    }\n    val = val[paths[idx]]\n    idx += 1\n  }\n  return val\n}\n\n\nfunction set (paths, value, obj) {\n  var schema = obj\n  var pList = Array.isArray(paths) ? paths : paths.split('.')\n  var len = pList.length\n  for(var i = 0; i < len-1; i++) {\n      var elem = pList[i]\n      if( !schema[elem] ) schema[elem] = {}\n      schema = schema[elem]\n  }\n\n  schema[pList[len-1]] = value\n}\n\nclass MyElement extends HTMLElement {\n  constructor () {\n    super(...arguments)\n\n    this._listeners = []\n    this._mapper = {}\n    this.context = SingleSlim.getInstance()\n    this._ctxMapper = {}\n\n    if (!this.shadowRoot) {\n      // Attach shadow DOM\n      this.attachShadow({mode: 'open'})\n      // Append template content to custom element\n      this.shadowRoot.appendChild(this.template.content.cloneNode(true))\n    }\n  }\n\n  connectedCallback () {\n    this.applyListeners()\n    this.activateState()\n    this.activateContext()\n  }\n\n  activateState () {\n    const instance = this\n\n    const initial = (\n      instance.data instanceof Function\n      ? instance.data\n      : () => (instance.data || {})\n    )()\n\n    this.shadowRoot.querySelectorAll('*')\n      .map(node => {\n        // Attribute sync\n        Array.from(node.attributes)\n          // e.g. :value\n          .filter(attr => attr.name.startsWith(':'))\n          .map(attr => {\n            const name = attr.name.slice(1)\n            node.removeAttribute(attr.name)\n            if (name === 'children') {\n              node.innerText = path(attr.value, initial)\n            } else node.setAttribute(name, path(attr.value, initial))\n            if (this._mapper.hasOwnProperty(attr.value)) {\n              this._mapper[attr.value].push({name, node})\n            } else this._mapper[attr.value] = [{name, node}]\n          })\n      })\n\n    this.data = slim.create(\n      initial,\n      true,\n      changes => {\n        changes.map(change => {\n          console.log(change.currentPath, instance._mapper)\n          Object.keys(instance._mapper)\n            .filter(paths => paths.startsWith(change.currentPath))\n            .map(paths =>\n              instance._mapper[paths].map(\n                ({name, node}) => {\n                  const newNode = path(paths, instance.data)\n                  if (name === 'children') {\n                    node.innerText = newNode\n                  } else {\n                    node.setAttribute(name, newNode)\n                    // HACK: not sure if value attribute is the only one that sets default rather than live value?\n                    if (name === 'value') node.value = newNode\n                  }\n                }\n              )\n            )\n      })\n      }\n    )\n  }\n\n  diactivateState () {\n    slim.remove(this.data)\n  }\n\n  activateContext () {\n    const instance = this\n\n    Array.from(this.attributes)\n      // e.g. :value\n      .filter(attr => attr.name.startsWith('~'))\n      .map(attr => {\n        const name = attr.name.slice(1)\n        this.removeAttribute(attr.name)\n        if (this._ctxMapper.hasOwnProperty(attr.value)) {\n          this._ctxMapper[attr.value].push({name, node: this})\n        } else this._ctxMapper[attr.value] = [{name, node: this}]\n      })\n\n    slim.observe(SingleSlim.getInstance(), changes => {\n      changes.map(change => {\n        // console.log(change.currentPath, instance._ctxMapper)\n        Object.keys(instance._ctxMapper)\n          .filter(paths => paths.startsWith(change.currentPath))\n          .map(paths =>\n            instance._ctxMapper[paths].map(\n              ({name, node}) => {\n                console.log(name, node)\n                const newNode = path(paths, instance.context)\n                set(name, newNode, instance.data)\n              }\n            )\n          )\n      })\n    })\n  }\n\n  disconnectedCallback () {\n    this.clearListeners()\n    this.diactivateState()\n  }\n\n  applyListeners () {\n    const instance = this\n\n    this.shadowRoot.querySelectorAll('*')\n      .map(node =>\n        Array.from(node.attributes)\n          // e.g. @click\n          .filter(attr => attr.name.startsWith('@'))\n          .map(attr => {\n            node.removeAttribute(attr.name)\n            if (instance[attr.value] instanceof Function) {\n              const handler = instance[attr.value].bind(instance)\n              node.addEventListener(attr.name.slice(1), handler)\n              instance._listeners.push({el: node, event: attr.name.slice(1), handler})\n            }\n          })\n      )\n  }\n\n  clearListeners () {\n    this._listeners.map(({el, event, handler}) => el.removeEventListener(event, handler))\n    this._listeners.length = 0\n  }\n}\n\nwindow.MyElement = MyElement\n\n// Define custom element\nwindow.exportTag = (name = '', Class = class extends MyElement {}) => {\n  Class.template = Class.prototype.template = document.currentScript.parentElement.querySelector('template')\n  return window.customElements.define(name, Class)\n}\n\nexport default MyElement\n"]}