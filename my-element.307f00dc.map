{"version":3,"sources":["node_modules/observable-slim/observable-slim.js","primitives/my-element.js"],"names":["SingleSlim","instance","createInstance","object","create","getInstance","path","paths","obj","Array","isArray","split","val","idx","length","set","value","schema","pList","len","i","elem","MyElement","arguments","observe","_listeners","_mapper","context","_ctxMapper","initState","shadowRoot","attachShadow","mode","appendChild","template","content","cloneNode","compile","initial","data","Function","changes","map","Object","keys","filter","startsWith","change","currentPath","name","node","newNode","innerText","setAttribute","root","overrides","querySelectorAll","attributes","iterable","removeAttribute","style","display","className","fragment","document","createDocumentFragment","elements","renderList","element","parentNode","removeChild","single","index","applyListeners","activateBinds","assign","activateContext","bind","insertBefore","nextSibling","find","attr","from","slice","hasOwnProperty","push","remove","clearListeners","diactivateState","diactivateContext","handler","addEventListener","el","event","removeEventListener","HTMLElement","window","exportTag","Class","prototype","currentScript","parentElement","querySelector","customElements","define"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjgBA;;;;;;;;;;;;;;AAEA,IAAMA,aAAc,YAAM;AACxB,MAAIC,iBAAJ;;AAEA,WAASC,cAAT,GAA0B;AACxB,QAAMC,SAAS,yBAAKC,MAAL,CAAY,EAAZ,EAAgB,IAAhB,CAAf;AACA,WAAOD,MAAP;AACD;;AAED,SAAO;AACLE,eADK,yBACS;AACZ,UAAI,CAACJ,QAAL,EAAe;AACbA,mBAAWC,gBAAX;AACD;AACD,aAAOD,QAAP;AACD;AANI,GAAP;AAQD,CAhBkB,EAAnB;;AAkBA,SAASK,IAAT,CAAcC,KAAd,EAAqBC,GAArB,EAA0B;AACxBD,UAAQE,MAAMC,OAAN,CAAcH,KAAd,IAAuBA,KAAvB,GAA+BA,MAAMI,KAAN,CAAY,GAAZ,CAAvC;AACA,MAAIC,MAAMJ,GAAV;AACA,MAAIK,MAAM,CAAV;AACA,SAAOA,MAAMN,MAAMO,MAAnB,EAA2B;AACzB,QAAIF,OAAO,IAAX,EAAiB;AACf;AACD;AACDA,UAAMA,IAAIL,MAAMM,GAAN,CAAJ,CAAN;AACAA,WAAO,CAAP;AACD;AACD,SAAOD,GAAP;AACD;;AAGD,SAASG,GAAT,CAAaR,KAAb,EAAoBS,KAApB,EAA2BR,GAA3B,EAAgC;AAC9B,MAAIS,SAAST,GAAb;AACA,MAAIU,QAAQT,MAAMC,OAAN,CAAcH,KAAd,IAAuBA,KAAvB,GAA+BA,MAAMI,KAAN,CAAY,GAAZ,CAA3C;AACA,MAAIQ,MAAMD,MAAMJ,MAAhB;AACA,OAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAID,MAAM,CAA1B,EAA6BC,GAA7B,EAAkC;AAChC,QAAIC,OAAOH,MAAME,CAAN,CAAX;AACA,QAAI,CAACH,OAAOI,IAAP,CAAL,EAAmBJ,OAAOI,IAAP,IAAe,EAAf;AACnBJ,aAASA,OAAOI,IAAP,CAAT;AACD;;AAEDJ,SAAOC,MAAMC,MAAM,CAAZ,CAAP,IAAyBH,KAAzB;AACD;;IAEKM;;;AAGJ,uBAAc;AAAA;;AAAA,uHACHC,SADG;;AAAA,UAFdC,OAEc,GAFJ,yBAAKA,OAED;;;AAGZ,UAAKC,UAAL,GAAkB,EAAlB;AACA,UAAKC,OAAL,GAAe,EAAf;AACA,UAAKC,OAAL,GAAe3B,WAAWK,WAAX,EAAf;AACA,UAAKuB,UAAL,GAAkB,EAAlB;AACA,UAAKC,SAAL;;AAEA,QAAI,CAAC,MAAKC,UAAV,EAAsB;AACpB;AACA,YAAKC,YAAL,CAAkB;AAChBC,cAAM;AADU,OAAlB;AAGA;AACA,YAAKF,UAAL,CAAgBG,WAAhB,CAA4B,MAAKC,QAAL,CAAcC,OAAd,CAAsBC,SAAtB,CAAgC,IAAhC,CAA5B;AACD;AAhBW;AAiBb;;;;wCAEmB;AAClB,WAAKC,OAAL;AACD;;;gCAEW;AACV,UAAMpC,WAAW,IAAjB;;AAEA,UAAMqC,UAAU,CACdrC,SAASsC,IAAT,YAAyBC,QAAzB,GACAvC,SAASsC,IADT,GAEA;AAAA,eAAOtC,SAASsC,IAAT,IAAiB,EAAxB;AAAA,OAHc,GAAhB;;AAMA,WAAKA,IAAL,GAAY,yBAAKnC,MAAL,CACVkC,OADU,EAEV,IAFU,EAGV,mBAAW;AACTG,gBAAQC,GAAR,CAAY,kBAAU;AACpBC,iBAAOC,IAAP,CAAY3C,SAASyB,OAArB,EACGmB,MADH,CACU;AAAA,mBAAStC,MAAMuC,UAAN,CAAiBC,OAAOC,WAAxB,CAAT;AAAA,WADV,EAEGN,GAFH,CAEO;AAAA,mBACHzC,SAASyB,OAAT,CAAiBnB,KAAjB,EAAwBmC,GAAxB,CACE,gBAGM;AAAA,kBAFJO,IAEI,QAFJA,IAEI;AAAA,kBADJC,IACI,QADJA,IACI;;AACJ,kBAAMC,UAAU7C,KAAKC,KAAL,EAAYN,SAASsC,IAArB,CAAhB;AACA,kBAAIU,SAAS,UAAb,EAAyB;AACvBC,qBAAKE,SAAL,GAAiBD,OAAjB;AACD,eAFD,MAEO;AACLD,qBAAKG,YAAL,CAAkBJ,IAAlB,EAAwBE,OAAxB;AACA;AACA,oBAAIF,SAAS,OAAb,EAAsBC,KAAKlC,KAAL,GAAamC,OAAb;AACvB;AACF,aAbH,CADG;AAAA,WAFP;AAmBD,SApBD;AAqBD,OAzBS,CAAZ;AA2BD;;;8BAE+C;AAAA;;AAAA,UAAxCG,IAAwC,uEAAjC,KAAKxB,UAA4B;AAAA,UAAhByB,SAAgB,uEAAJ,EAAI;;AAC9C,UAAMtD,WAAW,IAAjB;;AAEAqD,WAAKE,gBAAL,CAAsB,SAAtB,EACGd,GADH,CACO,gBAAQ;AAAA,mCACcQ,KAAKO,UAAL,CAAgB,OAAhB,EAAyBzC,KAAzB,CAA+BL,KAA/B,CAAqC,GAArC,CADd;AAAA;AAAA,YACJsC,IADI;AAAA,YACES,QADF;;AAEXR,aAAKS,eAAL,CAAqB,OAArB;AACA,YAAMzB,WAAWgB,KAAKd,SAAL,CAAe,IAAf,CAAjB;AACA;AACAc,aAAKU,KAAL,CAAWC,OAAX,GAAqB,MAArB;AACAX,aAAKY,SAAL,GAAiB,EAAjB;;AAEA,YAAMC,WAAWC,SAASC,sBAAT,EAAjB;AACA,YAAIC,WAAW,EAAf;;AAEA,YAAMC,aAAa,SAAbA,UAAa,UAAW;AAC5B;AACAD,mBAASxB,GAAT,CAAa;AAAA,mBAAW0B,QAAQC,UAAR,CAAmBC,WAAnB,CAA+BF,OAA/B,CAAX;AAAA,WAAb;AACA;AACAF,qBAAW5D,KAAKoD,QAAL,EAAezD,SAASsC,IAAxB,EACRG,GADQ,CACJ,UAAC6B,MAAD,EAASC,KAAT,EAAmB;AACtB,gBAAMJ,UAAUlC,SAASE,SAAT,CAAmB,IAAnB,CAAhB;AACAgC,oBAAQf,YAAR,CAAqB,KAArB,EAA4BmB,KAA5B;AACA,mBAAKC,cAAL,CAAoBL,OAApB;AACA,mBAAKM,aAAL,CAAmBN,OAAnB,EAA4BzB,OAAOgC,MAAP,CAAc,EAAd,EAAkBpB,SAAlB,sBAA+BN,IAA/B,EAAsCsB,MAAtC,EAA5B;AACA,mBAAKK,eAAL,CAAqBR,OAArB;AACA,mBAAK/B,OAAL,CAAa+B,OAAb,EAAsBzB,OAAOgC,MAAP,CAAc,EAAd,EAAkBpB,SAAlB,sBAA+BN,IAA/B,EAAsCsB,MAAtC,EAAtB;AACA,mBAAOH,OAAP;AACD,WATQ,CAAX;;AAWAF,mBAASxB,GAAT,CAAaqB,SAAS9B,WAAT,CAAqB4C,IAArB,CAA0Bd,QAA1B,CAAb;AACAb,eAAKmB,UAAL,CAAgBS,YAAhB,CAA6Bf,QAA7B,EAAuCb,KAAK6B,WAA5C;AACD,SAjBD;;AAmBA9E,iBAASuB,OAAT,CAAiBvB,SAASsC,IAA1B,EAAgC4B,WAAWU,IAAX,CAAgB5E,QAAhB,CAAhC;AACAkE;AACD,OAjCH;;AAmCA;AACAb,WAAKE,gBAAL,CAAsB,GAAtB,EACGX,MADH,CACU;AAAA,eAAQ,CAACF,OAAOC,IAAP,CAAYM,KAAKO,UAAjB,EAA6BuB,IAA7B,CAAkC;AAAA,iBAAQC,KAAKnC,UAAL,CAAgB,IAAhB,CAAR;AAAA,SAAlC,CAAT;AAAA,OADV,EAEGJ,GAFH,CAEO,gBAAQ;AACX,eAAK+B,cAAL,CAAoBvB,IAApB;AACA,eAAKwB,aAAL,CAAmBxB,IAAnB,EAAyBK,SAAzB;AACA,eAAKqB,eAAL,CAAqB1B,IAArB;AACD,OANH;AAOD;;;kCAEaA,MAAsB;AAAA;;AAAA,UAAhBK,SAAgB,uEAAJ,EAAI;;AAClC,UAAMtD,WAAW,IAAjB;;AAEAQ,YAAMyE,IAAN,CAAWhC,KAAKO,UAAhB;AACE;AADF,OAEGZ,MAFH,CAEU;AAAA,eAAQoC,KAAKhC,IAAL,CAAUH,UAAV,CAAqB,GAArB,CAAR;AAAA,OAFV,EAGGJ,GAHH,CAGO,gBAAQ;AACXQ,aAAKS,eAAL,CAAqBsB,KAAKhC,IAA1B;AACA,YAAMA,OAAOgC,KAAKhC,IAAL,CAAUkC,KAAV,CAAgB,CAAhB,CAAb;AACA,YAAMnE,QAAQuC,UAAU0B,KAAKjE,KAAf,KAAyBV,KAAK2E,KAAKjE,KAAV,EAAiB,OAAKuB,IAAtB,CAAvC;AACA,YAAIU,SAAS,UAAb,EAAyB;AACvBC,eAAKE,SAAL,GAAiBpC,KAAjB;AACD,SAFD,MAEOkC,KAAKG,YAAL,CAAkBJ,IAAlB,EAAwBjC,KAAxB;AACP,YAAI,OAAKU,OAAL,CAAa0D,cAAb,CAA4BH,KAAKjE,KAAjC,CAAJ,EAA6C;AAC3C,iBAAKU,OAAL,CAAauD,KAAKjE,KAAlB,EAAyBqE,IAAzB,CAA8B,EAACpC,UAAD,EAAOC,UAAP,EAA9B;AACD,SAFD,MAEO,OAAKxB,OAAL,CAAauD,KAAKjE,KAAlB,IAA2B,CAAC,EAACiC,UAAD,EAAOC,UAAP,EAAD,CAA3B;AACR,OAbH;AAcD;;;sCAEiB;AAChB,+BAAKoC,MAAL,CAAY,KAAK/C,IAAjB;AACD;;;oCAEeW,MAAM;AACpB,UAAMjD,WAAW,IAAjB;;AAEAQ,YAAMyE,IAAN,CAAWhC,KAAKO,UAAhB;AACE;AADF,OAEGZ,MAFH,CAEU;AAAA,eAAQoC,KAAKhC,IAAL,CAAUH,UAAV,CAAqB,GAArB,CAAR;AAAA,OAFV,EAGGJ,GAHH,CAGO,gBAAQ;AACX,YAAMO,OAAOgC,KAAKhC,IAAL,CAAUkC,KAAV,CAAgB,CAAhB,CAAb;AACAjC,aAAKS,eAAL,CAAqBsB,KAAKhC,IAA1B;AACA,YAAIhD,SAAS2B,UAAT,CAAoBwD,cAApB,CAAmCH,KAAKjE,KAAxC,CAAJ,EAAoD;AAClDf,mBAAS2B,UAAT,CAAoBqD,KAAKjE,KAAzB,EAAgCqE,IAAhC,CAAqC;AACnCpC,sBADmC;AAEnCC;AAFmC,WAArC;AAID,SALD,MAKOjD,SAAS2B,UAAT,CAAoBqD,KAAKjE,KAAzB,IAAkC,CAAC;AACxCiC,oBADwC;AAExCC;AAFwC,SAAD,CAAlC;AAIR,OAfH;;AAiBA,+BAAK1B,OAAL,CAAaxB,WAAWK,WAAX,EAAb,EAAuC,mBAAW;AAChDoC,gBAAQC,GAAR,CAAY,kBAAU;AACpB;AACAC,iBAAOC,IAAP,CAAY3C,SAAS2B,UAArB,EACGiB,MADH,CACU;AAAA,mBAAStC,MAAMuC,UAAN,CAAiBC,OAAOC,WAAxB,CAAT;AAAA,WADV,EAEGN,GAFH,CAEO;AAAA,mBACHzC,SAAS2B,UAAT,CAAoBrB,KAApB,EAA2BmC,GAA3B,CACE,iBAGM;AAAA,kBAFJO,IAEI,SAFJA,IAEI;AAAA,kBADJC,IACI,SADJA,IACI;;AACJ,kBAAMC,UAAU7C,KAAKC,KAAL,EAAYN,SAAS0B,OAArB,CAAhB;AACA,kBAAIsB,SAAS,UAAb,EAAyB;AACvBC,qBAAKE,SAAL,GAAiBD,OAAjB;AACD,eAFD,MAEO;AACLD,qBAAKG,YAAL,CAAkBJ,IAAlB,EAAwBE,OAAxB;AACA;AACA,oBAAIF,SAAS,OAAb,EAAsBC,KAAKlC,KAAL,GAAamC,OAAb;AACvB;AACF,aAbH,CADG;AAAA,WAFP;AAmBD,SArBD;AAsBD,OAvBD;AAwBD;;;2CAEsB;AACrB,WAAKoC,cAAL;AACA,WAAKC,eAAL;AACA,WAAKC,iBAAL;AACD;;;mCAEcvC,MAAM;AACnB,UAAMjD,WAAW,IAAjB;;AAEAQ,YAAMyE,IAAN,CAAWhC,KAAKO,UAAhB;AACE;AADF,OAEGZ,MAFH,CAEU;AAAA,eAAQoC,KAAKhC,IAAL,CAAUH,UAAV,CAAqB,GAArB,CAAR;AAAA,OAFV,EAGGJ,GAHH,CAGO,gBAAQ;AACXQ,aAAKS,eAAL,CAAqBsB,KAAKhC,IAA1B;AACA,YAAIhD,SAASgF,KAAKjE,KAAd,aAAgCwB,QAApC,EAA8C;AAC5C,cAAMkD,UAAUzF,SAASgF,KAAKjE,KAAd,EAAqB6D,IAArB,CAA0B5E,QAA1B,CAAhB;AACAiD,eAAKyC,gBAAL,CAAsBV,KAAKhC,IAAL,CAAUkC,KAAV,CAAgB,CAAhB,CAAtB,EAA0CO,OAA1C;AACAzF,mBAASwB,UAAT,CAAoB4D,IAApB,CAAyB;AACvBO,gBAAI1C,IADmB;AAEvB2C,mBAAOZ,KAAKhC,IAAL,CAAUkC,KAAV,CAAgB,CAAhB,CAFgB;AAGvBO;AAHuB,WAAzB;AAKD;AACF,OAdH;AAeD;;;qCAEgB;AACf,WAAKjE,UAAL,CAAgBiB,GAAhB,CAAoB;AAAA,YAClBkD,EADkB,SAClBA,EADkB;AAAA,YAElBC,KAFkB,SAElBA,KAFkB;AAAA,YAGlBH,OAHkB,SAGlBA,OAHkB;AAAA,eAIdE,GAAGE,mBAAH,CAAuBD,KAAvB,EAA8BH,OAA9B,CAJc;AAAA,OAApB;AAKA,WAAKjE,UAAL,CAAgBX,MAAhB,GAAyB,CAAzB;AACD;;;;EAtNqBiF;;AAyNxBC,OAAO1E,SAAP,GAAmBA,SAAnB;;AAEA;AACA0E,OAAOC,SAAP,GAAmB,YAAmD;AAAA,MAAlDhD,IAAkD,uEAA3C,EAA2C;AAAA,MAAvCiD,KAAuC;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,IAAjB5E,SAAiB;;AACpE4E,QAAMhE,QAAN,GAAiBgE,MAAMC,SAAN,CAAgBjE,QAAhB,GAA2B8B,SAASoC,aAAT,CAAuBC,aAAvB,CAAqCC,aAArC,CAAmD,UAAnD,CAA5C;AACA,SAAON,OAAOO,cAAP,CAAsBC,MAAtB,CAA6BvD,IAA7B,EAAmCiD,KAAnC,CAAP;AACD,CAHD;;kBAKe5E","file":"my-element.307f00dc.map","sourceRoot":"../client","sourcesContent":["/*\r\n * \tObservable Slim\r\n *\tVersion 0.0.1\r\n * \thttps://github.com/elliotnb/observable-slim\r\n *\r\n * \tLicensed under the MIT license:\r\n * \thttp://www.opensource.org/licenses/MIT\r\n *\r\n *\tObservable Slim is a singleton that allows you to observe changes made to an object and any nested\r\n *\tchildren of that object. It is intended to assist with one-way data binding, that is, in MVC parlance, \r\n *\treflecting changes in the model to the view. Observable Slim aspires to be as lightweight and easily\r\n *\tunderstood as possible. Minifies down to roughly 3000 characters.\r\n */\r\n\r\n\r\nvar ObservableSlim = (function() {\r\n\t\r\n\t// An array that stores all of the observables created through the public create() method below.\r\n\tvar observables = [];\r\n\t// An array of all the objects that we have assigned Proxies to\r\n\tvar targets = [];\r\n\r\n\t// An array of arrays containing the Proxies created for each target object. targetsProxy is index-matched with \r\n\t// 'targets' -- together, the pair offer a Hash table where the key is not a string nor number, but the actual target object\r\n\tvar targetsProxy = [];\r\n\t\r\n\t// this variable tracks duplicate proxies assigned to the same target.\r\n\t// the 'set' handler below will trigger the same change on all other Proxies tracking the same target.\r\n\t// however, in order to avoid an infinite loop of Proxies triggering and re-triggering one another, we use dupProxy\r\n\t// to track that a given Proxy was modified from the 'set' handler\r\n\tvar dupProxy = null;\r\n\r\n\tvar _getProperty = function(obj, path) {\r\n\t\treturn path.split('.').reduce(function(prev, curr) {\r\n\t\t\treturn prev ? prev[curr] : undefined\r\n\t\t}, obj || self)\r\n\t};\r\n\t\r\n\t/*\tFunction: _create\r\n\t\t\t\tPrivate internal function that is invoked to create a new ES6 Proxy whose changes we can observe through \r\n\t\t\t\tthe Observerable.observe() method.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\ttarget \t\t\t\t- required, plain JavaScript object that we want to observe for changes.\r\n\t\t\t\tdomDelay \t\t\t- batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n\t\t\t\toriginalObservable \t- object, the original observable created by the user, exists for recursion purposes, \r\n\t\t\t\t\t\t\t\t\t  allows one observable to observe change on any nested/child objects.\r\n\t\t\t\toriginalPath \t\t- string, the path of the property in relation to the target on the original observable, \r\n\t\t\t\t\t\t\t\t\t  exists for recursion purposes, allows one observable to observe change on any nested/child objects.\r\n\t\t\t\t\t\t\t\t\t  \r\n\t\t\tReturns:\r\n\t\t\t\tAn ES6 Proxy object.\r\n\t*/\r\n\tvar _create = function(target, domDelay, originalObservable, originalPath) {\r\n\t\t\r\n\t\tvar observable = originalObservable || null;\r\n\t\tvar path = originalPath || \"\";\r\n\t\t\r\n\t\tvar changes = [];\r\n\t\t\r\n\t\tvar _getPath = function(target, property) {\r\n\t\t\tif (target instanceof Array) {\r\n\t\t\t\treturn (path !== \"\") ? (path) : property;\r\n\t\t\t} else {\r\n\t\t\t\treturn (path !== \"\") ? (path + \".\" + property) : property;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar _notifyObservers = function(numChanges) {\r\n\t\t\t\r\n\t\t\t// if the observable is paused, then we don't want to execute any of the observer functions\r\n\t\t\tif (observable.paused === true) return;\r\n\t\t\t\t\t\r\n\t\t\t// execute observer functions on a 10ms settimeout, this prevents the observer functions from being executed \r\n\t\t\t// separately on every change -- this is necessary because the observer functions will often trigger UI updates\r\n \t\t\tif (domDelay === true) {\r\n\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\tif (numChanges === changes.length) {\r\n\t\t\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changes);\r\n\t\t\t\t\t\tchanges = [];\r\n\t\t\t\t\t}\r\n\t\t\t\t},10);\r\n\t\t\t} else {\r\n\t\t\t\t// invoke any functions that are observing changes\r\n\t\t\t\tfor (var i = 0; i < observable.observers.length; i++) observable.observers[i](changes);\r\n\t\t\t\tchanges = [];\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar handler = { \r\n\t\t\tget: function(target, property) {\r\n\t\t\t\t\r\n\t\t\t\t// implement a simple check for whether or not the object is a proxy, this helps the .create() method avoid\r\n\t\t\t\t// creating Proxies of Proxies.\r\n\t\t\t\tif (property === \"__getTarget\") {\r\n\t\t\t\t\treturn target;\r\n\t\t\t\t} else if (property === \"__isProxy\") {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t// from the perspective of a given observable on a parent object, return the parent object of the given nested object\r\n\t\t\t\t} else if (property === \"__getParent\") {\r\n\t\t\t\t\treturn function(i) {\r\n\t\t\t\t\t\tif (typeof i === \"undefined\") var i = 1;\r\n\t\t\t\t\t\tvar parentPath = _getPath(target, \"__getParent\").split(\".\");\r\n\t\t\t\t\t\tparentPath.splice(-(i+1),(i+1));\r\n\t\t\t\t\t\treturn _getProperty(observable.parentProxy, parentPath.join(\".\"));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// for performance improvements, we assign this to a variable so we do not have to lookup the property value again\r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\t\r\n\t\t\t\t// if we are traversing into a new object, then we want to record path to that object and return a new observable.\r\n\t\t\t\t// recursively returning a new observable allows us a single Observable.observe() to monitor all changes on \r\n\t\t\t\t// the target object and any objects nested within.\t\t\t\t\r\n\t\t\t\tif (targetProp instanceof Object && targetProp !== null && target.hasOwnProperty(property)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we've found a proxy nested on the object, then we want to retrieve the original object behind that proxy\r\n\t\t\t\t\tif (targetProp.__isProxy === true) targetProp = targetProp.__getTarget;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we've previously setup a proxy on this target, then...\r\n\t\t\t\t\t//var a = observable.targets.indexOf(targetProp);\r\n\t\t\t\t\tvar a = -1;\r\n\t\t\t\t\tvar observableTargets = observable.targets;\r\n\t\t\t\t\tfor (var i = 0, l = observableTargets.length; i < l; i++) {\r\n\t\t\t\t\t\tif (targetProp === observableTargets[i]) {\r\n\t\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (a > -1) return observable.proxies[a];\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we're arrived here, then that means there is no proxy for the object the user just accessed, so we\r\n\t\t\t\t\t// have to create a new proxy for it\r\n\t\t\t\t\tvar newPath = (path !== \"\") ? (path + \".\" + property) : property;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn _create(targetProp, domDelay, observable, newPath);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn targetProp;\r\n\t\t\t\t}\r\n\t\t\t},\r\n \t\t\tdeleteProperty: function(target, property) {\r\n\t\t\t\t\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// in order to report what the previous value was, we must make a copy of it before it is deleted\r\n\t\t\t\tvar previousValue = Object.assign({}, target);\r\n \r\n\t\t\t\t// get the path of the property being deleted\r\n\t\t\t\tvar currentPath = _getPath(target, property);\r\n\t\t\t\t\r\n\t\t\t\t// record the deletion that just took place\r\n\t\t\t\tchanges.push({\"type\":\"delete\",\"target\":target,\"property\":property,\"newValue\":null,\"previousValue\":previousValue[property],\"currentPath\":currentPath,\"proxy\":proxy});\r\n\t\t\t\t\r\n\t\t\t\tif (originalChange === true) {\r\n\t\t\t\t\r\n\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\t\t\t\t\r\n\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\tvar currentTargetProxy = targetsProxy[a];\r\n\r\n\t\t\t\t\tvar b = currentTargetProxy.length;\r\n\t\t\t\t\twhile (b--) {\r\n\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\t\t\t\t\r\n\t\t\t\t\t\t\t// make the same delete on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\tdelete currentTargetProxy[b].proxy[property];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\t// perform the delete that we've trapped\r\n\t\t\t\t\tdelete target[property];\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\tset: function(target, property, value, receiver) {\r\n\t\t\t\r\n\t\t\t\t// was this change an original change or was it a change that was re-triggered below\r\n\t\t\t\tvar originalChange = true;\r\n\t\t\t\tif (dupProxy === proxy) {\r\n\t\t\t\t\toriginalChange = false;\r\n\t\t\t\t\tdupProxy = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// improve performance by saving direct references to the property \r\n\t\t\t\tvar targetProp = target[property];\r\n\t\t\t\t\r\n\t\t\t\t// only record a change if the new value differs from the old one OR if this proxy was not the original proxy to receive the change\r\n\t\t\t\tif (targetProp !== value || originalChange === false) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar typeOfTargetProp = (typeof targetProp);\r\n\t\t\t\t\r\n\t\t\t\t\t// get the path of the object property being modified\r\n\t\t\t\t\tvar currentPath = _getPath(target, property);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// determine if we're adding something new or modifying somethat that already existed\r\n\t\t\t\t\tvar type = \"update\";\r\n\t\t\t\t\tif (typeOfTargetProp === \"undefined\") type = \"add\";\r\n\t\t\t\t\t\r\n\t\t\t\t\t// store the change that just occurred. it is important that we store the change before invoking the other proxies so that the previousValue is correct\r\n\t\t\t\t\tchanges.push({\"type\":type,\"target\":target,\"property\":property,\"newValue\":value,\"previousValue\":receiver[property],\"currentPath\":currentPath,\"proxy\":proxy});\r\n\t\t\t\t\t\r\n\t\t\t\t\t// !!IMPORTANT!! if this proxy was the first proxy to receive the change, then we need to go check and see\r\n\t\t\t\t\t// if there are other proxies for the same project. if there are, then we will modify those proxies as well so the other\r\n\t\t\t\t\t// observers can be modified of the change that has occurred.\r\n\t\t\t\t\tif (originalChange === true) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfor (var a = 0, l = targets.length; a < l; a++) if (target === targets[a]) break;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// loop over each proxy and see if the target for this change has any other proxies\r\n\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[a];\r\n\t\t\t\t\t\tfor (var b = 0, l = currentTargetProxy.length; b < l; b++) {\r\n\t\t\t\t\t\t\t// if the same target has a different proxy\r\n\t\t\t\t\t\t\tif (currentTargetProxy[b].proxy !== proxy) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// !!IMPORTANT!! store the proxy as a duplicate proxy (dupProxy) -- this will adjust the behavior above appropriately (that is,\r\n\t\t\t\t\t\t\t\t// prevent a change on dupProxy from re-triggering the same change on other proxies)\r\n\t\t\t\t\t\t\t\tdupProxy = currentTargetProxy[b].proxy;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// invoke the same change on the different proxy for the same target object. it is important that we make this change *after* we invoke the same change\r\n\t\t\t\t\t\t\t\t// on any other proxies so that the previousValue can show up correct for the other proxies\r\n\t\t\t\t\t\t\t\tcurrentTargetProxy[b].proxy[property] = value;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the property being overwritten is an object, then that means this observable\r\n\t\t\t\t\t\t// will need to stop monitoring this object and any nested objects underneath else they'll become\r\n\t\t\t\t\t\t// orphaned and grow memory usage. we excute this on a setTimeout so that the clean-up process does not block\r\n\t\t\t\t\t\t// the UI rendering -- there's no need to execute the clean up immediately\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (typeOfTargetProp === \"object\" && targetProp !== null) {\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// loop over each property and recursively invoke the `iterate` function for any\r\n\t\t\t\t\t\t\t\t// objects nested on targetProp\r\n\t\t\t\t\t\t\t\t(function iterate(obj) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tvar keys = Object.keys(obj);\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tvar objProp = obj[keys[i]];\r\n\t\t\t\t\t\t\t\t\t\tif (objProp instanceof Object && objProp !== null) iterate(objProp);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if there are any existing target objects (objects that we're already observing)...\r\n\t\t\t\t\t\t\t\t\t//var c = targets.indexOf(obj);\r\n\t\t\t\t\t\t\t\t\tvar c = -1;\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\tif (obj === targets[i]) {\r\n\t\t\t\t\t\t\t\t\t\t\tc = i;\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (c > -1) {\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// ...then we want to determine if the observables for that object match our current observable\r\n\t\t\t\t\t\t\t\t\t\tvar currentTargetProxy = targetsProxy[c];\r\n\t\t\t\t\t\t\t\t\t\tvar d = currentTargetProxy.length;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\twhile (d--) {\r\n\t\t\t\t\t\t\t\t\t\t\t// if we do have an observable monitoring the object thats about to be overwritten\r\n\t\t\t\t\t\t\t\t\t\t\t// then we can remove that observable from the target object\r\n\t\t\t\t\t\t\t\t\t\t\tif (observable === currentTargetProxy[d].observable) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentTargetProxy.splice(d,1);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// if there are no more observables assigned to the target object, then we can remove\r\n\t\t\t\t\t\t\t\t\t\t// the target object altogether. this is necessary to prevent growing memory consumption particularly with large data sets\r\n\t\t\t\t\t\t\t\t\t\tif (currentTargetProxy.length == 0) {\r\n\t\t\t\t\t\t\t\t\t\t\ttargetsProxy.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t\ttargets.splice(c,1);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t})(targetProp)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},10000);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// because the value actually differs than the previous value\r\n\t\t\t\t\t\t// we need to store the new value on the original target object\r\n\t\t\t\t\t\ttarget[property] = value;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// TO DO: the next block of code resolves test case #24, but it results in poor IE11 performance. Find a solution.\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the value we've just set is an object, then we'll need to iterate over it in order to initialize the \r\n\t\t\t\t\t\t// observers/proxies on all nested children of the object\r\n\t\t\t\t\t\t/* if (value instanceof Object && value !== null) {\r\n\t\t\t\t\t\t\t(function iterate(proxy) {\r\n\t\t\t\t\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\t\t\t\t\tvar keys = Object.keys(target);\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t})(proxy[property]);\r\n\t\t\t\t\t\t}; */\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// notify the observer functions that the target has been modified\r\n\t\t\t\t\t_notifyObservers(changes.length);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// create the proxy that we'll use to observe any changes\r\n\t\tvar proxy = new Proxy(target, handler);\r\n\t\t\r\n\t\t// we don't want to create a new observable if this function was invoked recursively\r\n\t\tif (observable === null) {\r\n\t\t\tobservable = {\"parentTarget\":target, \"domDelay\":domDelay, \"parentProxy\":proxy, \"observers\":[],\"targets\":[target],\"proxies\":[proxy],\"paused\":false,\"path\":path};\r\n\t\t\tobservables.push(observable);\r\n\t\t} else {\r\n\t\t\tobservable.targets.push(target);\r\n\t\t\tobservable.proxies.push(proxy);\r\n\t\t}\r\n\r\n\t\t// store the proxy we've created so it isn't re-created unnecessairly via get handler\r\n\t\tvar proxyItem = {\"target\":target,\"proxy\":proxy,\"observable\":observable};\r\n\t\t\r\n\t\t//var targetPosition = targets.indexOf(target);\r\n\t\tvar targetPosition = -1;\r\n\t\tfor (var i = 0, l = targets.length; i < l; i++) {\r\n\t\t\tif (target === targets[i]) {\r\n\t\t\t\ttargetPosition = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// if we have already created a Proxy for this target object then we add it to the corresponding array \r\n\t\t// on targetsProxy (targets and targetsProxy work together as a Hash table indexed by the actual target object).\r\n\t\tif (targetPosition > -1) {\r\n\t\t\ttargetsProxy[targetPosition].push(proxyItem);\r\n\t\t// else this is a target object that we have not yet created a Proxy for, so we must add it to targets,\r\n\t\t// and push a new array on to targetsProxy containing the new Proxy\r\n\t\t} else {\r\n\t\t\ttargets.push(target);\r\n\t\t\ttargetsProxy.push([proxyItem]);\r\n\t\t\ttargetPosition = targets.length - 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn proxy;\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/*\tMethod:\r\n\t\t\t\tPublic method that is invoked to create a new ES6 Proxy whose changes we can observe \r\n\t\t\t\tthrough the Observerable.observe() method.\r\n\t\t\t\r\n\t\t\tParameters\r\n\t\t\t\ttarget - Object, required, plain JavaScript object that we want to observe for changes.\r\n\t\t\t\tdomDelay - Boolean, required, if true, then batch up changes on a 10ms delay so a series of changes can be processed in one DOM update.\r\n\t\t\t\tobserver - Function, optional, will be invoked when a change is made to the proxy.\r\n\t\t\t\r\n\t\t\tReturns:\r\n\t\t\t\tAn ES6 Proxy object.\r\n\t\t*/\r\n\t\tcreate: function(target, domDelay, observer) {\r\n\t\t\t\r\n\t\t\t// test if the target is a Proxy, if it is then we need to retrieve the original object behind the Proxy.\r\n\t\t\t// we do not allow creating proxies of proxies because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\tif (target.__isProxy === true) {\r\n\t\t\t\tvar target = target.__getTarget;\r\n\t\t\t\t//if it is, then we should throw an error. we do not allow creating proxies of proxies\r\n\t\t\t\t// because -- given the recursive design of ObservableSlim -- it would lead to sharp increases in memory usage\r\n\t\t\t\t//throw new Error(\"ObservableSlim.create() cannot create a Proxy for a target object that is also a Proxy.\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// fire off the _create() method -- it will create a new observable and proxy and return the proxy\r\n\t\t\tvar proxy = _create(target, domDelay);\r\n\t\t\t\r\n\t\t\t// assign the observer function\r\n\t\t\tif (typeof observer === \"function\") this.observe(proxy, observer);\r\n\t\t\t\r\n\t\t\t// recursively loop over all nested objects on the proxy we've just created\r\n\t\t\t// this will allow the top observable to observe any changes that occur on a nested object\r\n\t\t\t(function iterate(proxy) {\r\n\t\t\t\tvar target = proxy.__getTarget;\r\n\t\t\t\tvar keys  = Object.keys(target);\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar property = keys[i];\r\n\t\t\t\t\tif (target[property] instanceof Object && target[property] !== null) iterate(proxy[property]);\r\n\t\t\t\t}\r\n\t\t\t})(proxy);\r\n\t\t\t\r\n\t\t\treturn proxy;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: observe\r\n\t\t\t\tThis method is used to add a new observer function to an existing proxy.\r\n\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method. We want to observe changes made to this object.\r\n\t\t\t\tobserver \t- this function will be invoked when a change is made to the observable (not to be confused with the \r\n\t\t\t\t\t\t\t  observer defined in the create() method).\r\n\t\t\t\r\n\t\t\tReturns:\r\n\t\t\t\tNothing.\r\n\t\t*/\r\n\t\tobserve: function(proxy, observer) {\r\n\t\t\t// loop over all the observables created by the _create() function\r\n\t\t\tvar i = observables.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].observers.push(observer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: pause\r\n\t\t\t\tThis method will prevent any observer functions from being invoked when a change occurs to a proxy.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tpause: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = true;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not pause observable -- matching proxy not found.\");\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: resume\r\n\t\t\t\tThis method will resume execution of any observer functions when a change is made to a proxy.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tresume: function(proxy) {\r\n\t\t\tvar i = observables.length;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (observables[i].parentProxy === proxy) {\r\n\t\t\t\t\tobservables[i].paused = false;\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch == false) throw new Error(\"ObseravableSlim could not resume observable -- matching proxy not found.\");\r\n\t\t},\r\n\t\t\r\n\t\t/*\tMethod: remove\r\n\t\t\t\tThis method will remove the observable and proxy thereby preventing any further callback observers for \r\n\t\t\t\tchanges occuring to the target object.\r\n\t\t\t\r\n\t\t\tParameters:\r\n\t\t\t\tproxy \t- the ES6 Proxy returned by the create() method.\r\n\t\t*/\r\n\t\tremove: function(proxy) {\r\n\t\t\r\n\t\t\tvar matchedObservable = null;\r\n\t\t\tvar foundMatch = false;\r\n\t\t\t\r\n\t\t\tvar c = observables.length;\r\n\t\t\twhile (c--) {\r\n\t\t\t\tif (observables[c].parentProxy === proxy) {\r\n\t\t\t\t\tmatchedObservable = observables[c];\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar a = targetsProxy.length;\r\n\t\t\twhile (a--) {\r\n\t\t\t\tvar b = targetsProxy[a].length;\r\n\t\t\t\twhile (b--) {\r\n\t\t\t\t\tif (targetsProxy[a][b].observable === matchedObservable) {\r\n\t\t\t\t\t\ttargetsProxy[a].splice(b,1);\r\n\t\t\t\t\t\tif (targetsProxy[a].length == 0) {\r\n\t\t\t\t\t\t\ttargetsProxy.splice(a,1);\r\n\t\t\t\t\t\t\ttargets.splice(a,1);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (foundMatch === true) {\r\n\t\t\t\tobservables.splice(c,1);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n})();\r\n\r\n// Export in a try catch to prevent this from erroring out on older browsers\r\ntry { module.exports = ObservableSlim; } catch (err) {};","import slim from 'observable-slim'\n\nconst SingleSlim = (() => {\n  let instance\n\n  function createInstance() {\n    const object = slim.create({}, true)\n    return object\n  }\n\n  return {\n    getInstance() {\n      if (!instance) {\n        instance = createInstance()\n      }\n      return instance\n    }\n  }\n})()\n\nfunction path(paths, obj) {\n  paths = Array.isArray(paths) ? paths : paths.split('.')\n  let val = obj\n  let idx = 0\n  while (idx < paths.length) {\n    if (val == null) {\n      return\n    }\n    val = val[paths[idx]]\n    idx += 1\n  }\n  return val\n}\n\n\nfunction set(paths, value, obj) {\n  var schema = obj\n  var pList = Array.isArray(paths) ? paths : paths.split('.')\n  var len = pList.length\n  for (var i = 0; i < len - 1; i++) {\n    var elem = pList[i]\n    if (!schema[elem]) schema[elem] = {}\n    schema = schema[elem]\n  }\n\n  schema[pList[len - 1]] = value\n}\n\nclass MyElement extends HTMLElement {\n  observe = slim.observe\n\n  constructor() {\n    super(...arguments)\n\n    this._listeners = []\n    this._mapper = {}\n    this.context = SingleSlim.getInstance()\n    this._ctxMapper = {}\n    this.initState()\n\n    if (!this.shadowRoot) {\n      // Attach shadow DOM\n      this.attachShadow({\n        mode: 'open'\n      })\n      // Append template content to custom element\n      this.shadowRoot.appendChild(this.template.content.cloneNode(true))\n    }\n  }\n\n  connectedCallback() {\n    this.compile()\n  }\n\n  initState() {\n    const instance = this\n\n    const initial = (\n      instance.data instanceof Function ?\n      instance.data :\n      () => (instance.data || {})\n    )()\n\n    this.data = slim.create(\n      initial,\n      true,\n      changes => {\n        changes.map(change => {\n          Object.keys(instance._mapper)\n            .filter(paths => paths.startsWith(change.currentPath))\n            .map(paths =>\n              instance._mapper[paths].map(\n                ({\n                  name,\n                  node\n                }) => {\n                  const newNode = path(paths, instance.data)\n                  if (name === 'children') {\n                    node.innerText = newNode\n                  } else {\n                    node.setAttribute(name, newNode)\n                    // HACK: not sure if value attribute is the only one that sets default rather than live value?\n                    if (name === 'value') node.value = newNode\n                  }\n                }\n              )\n            )\n        })\n      }\n    )\n  }\n\n  compile(root = this.shadowRoot, overrides = {}) {\n    const instance = this\n\n    root.querySelectorAll('[x-for]')\n      .map(node => {\n        const [name, iterable] = node.attributes['x-for'].value.split(':')\n        node.removeAttribute('x-for')\n        const template = node.cloneNode(true)\n        // HACK: uses node itself as anchor so not removing it, but definitely not a nice solution\n        node.style.display = 'none'\n        node.className = ''\n\n        const fragment = document.createDocumentFragment()\n        let elements = []\n\n        const renderList = changes => {\n          // Clear current children\n          elements.map(element => element.parentNode.removeChild(element))\n          // Compile elements\n          elements = path(iterable, instance.data)\n            .map((single, index) => {\n              const element = template.cloneNode(true)\n              element.setAttribute('key', index)\n              this.applyListeners(element)\n              this.activateBinds(element, Object.assign({}, overrides, {[name]: single}))\n              this.activateContext(element)\n              this.compile(element, Object.assign({}, overrides, {[name]: single}))\n              return element\n            })\n\n          elements.map(fragment.appendChild.bind(fragment))\n          node.parentNode.insertBefore(fragment, node.nextSibling)\n        }\n\n        instance.observe(instance.data, renderList.bind(instance))\n        renderList()\n      })\n\n    // Apply listeners and data binding to nodes without directives\n    root.querySelectorAll('*')\n      .filter(node => !Object.keys(node.attributes).find(attr => attr.startsWith('x-')))\n      .map(node => {\n        this.applyListeners(node)\n        this.activateBinds(node, overrides)\n        this.activateContext(node)\n      })\n  }\n\n  activateBinds(node, overrides = {}) {\n    const instance = this\n\n    Array.from(node.attributes)\n      // e.g. :value\n      .filter(attr => attr.name.startsWith(':'))\n      .map(attr => {\n        node.removeAttribute(attr.name)\n        const name = attr.name.slice(1)\n        const value = overrides[attr.value] || path(attr.value, this.data)\n        if (name === 'children') {\n          node.innerText = value\n        } else node.setAttribute(name, value)\n        if (this._mapper.hasOwnProperty(attr.value)) {\n          this._mapper[attr.value].push({name, node})\n        } else this._mapper[attr.value] = [{name, node}]\n      })\n  }\n\n  diactivateState() {\n    slim.remove(this.data)\n  }\n\n  activateContext(node) {\n    const instance = this;\n\n    Array.from(node.attributes)\n      // e.g. :value\n      .filter(attr => attr.name.startsWith('~'))\n      .map(attr => {\n        const name = attr.name.slice(1)\n        node.removeAttribute(attr.name)\n        if (instance._ctxMapper.hasOwnProperty(attr.value)) {\n          instance._ctxMapper[attr.value].push({\n            name,\n            node\n          })\n        } else instance._ctxMapper[attr.value] = [{\n          name,\n          node\n        }]\n      })\n\n    slim.observe(SingleSlim.getInstance(), changes => {\n      changes.map(change => {\n        // console.log(change.currentPath, instance._ctxMapper)\n        Object.keys(instance._ctxMapper)\n          .filter(paths => paths.startsWith(change.currentPath))\n          .map(paths =>\n            instance._ctxMapper[paths].map(\n              ({\n                name,\n                node\n              }) => {\n                const newNode = path(paths, instance.context)\n                if (name === 'children') {\n                  node.innerText = newNode\n                } else {\n                  node.setAttribute(name, newNode)\n                  // HACK: not sure if value attribute is the only one that sets default rather than live value?\n                  if (name === 'value') node.value = newNode\n                }\n              }\n            )\n          )\n      })\n    })\n  }\n\n  disconnectedCallback() {\n    this.clearListeners()\n    this.diactivateState()\n    this.diactivateContext()\n  }\n\n  applyListeners(node) {\n    const instance = this\n\n    Array.from(node.attributes)\n      // e.g. @click\n      .filter(attr => attr.name.startsWith('@'))\n      .map(attr => {\n        node.removeAttribute(attr.name)\n        if (instance[attr.value] instanceof Function) {\n          const handler = instance[attr.value].bind(instance)\n          node.addEventListener(attr.name.slice(1), handler)\n          instance._listeners.push({\n            el: node,\n            event: attr.name.slice(1),\n            handler\n          })\n        }\n      })\n  }\n\n  clearListeners() {\n    this._listeners.map(({\n      el,\n      event,\n      handler\n    }) => el.removeEventListener(event, handler))\n    this._listeners.length = 0\n  }\n}\n\nwindow.MyElement = MyElement\n\n// Define custom element\nwindow.exportTag = (name = '', Class = class extends MyElement {}) => {\n  Class.template = Class.prototype.template = document.currentScript.parentElement.querySelector('template')\n  return window.customElements.define(name, Class)\n}\n\nexport default MyElement\n"]}